<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>PAlib: Référence du fichier PA_Sprite.h</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Généré par Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="index.html">Page&nbsp;principale</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">Liste&nbsp;des&nbsp;fichiers</a> | <a class="qindex" href="globals.html">Portée&nbsp;globale</a>  | <span class="search">Rechercher&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Référence du fichier PA_Sprite.h</h1>Everything concerning the sprite system. <a href="#_details">Plus de détails...</a>
<p>

<p>
<a href="_p_a___sprite_8h-source.html">Aller au code source de ce fichier.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Structures de données</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_sizes</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>mem_usage</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>obj_inf</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_DrawSprites</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>spriteanim</b></td></tr>

<tr><td colspan="2"><br><h2>Macros</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a0" doxytag="PA_Sprite.h::EWRAM_DATA"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EWRAM_DATA</b>&nbsp;&nbsp;&nbsp;__attribute__((section(".ewram")))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a1" doxytag="PA_Sprite.h::EWRAM_BSS"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EWRAM_BSS</b>&nbsp;&nbsp;&nbsp;__attribute__((section(".sbss")))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a2" doxytag="PA_Sprite.h::PA_Cos"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_Cos</b>(angle)&nbsp;&nbsp;&nbsp;PA_SIN[((angle) + 128)&amp;511]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3" doxytag="PA_Sprite.h::PA_Sin"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_Sin</b>(angle)&nbsp;&nbsp;&nbsp;PA_SIN[((angle))&amp;511]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a4" doxytag="PA_Sprite.h::MAX_DRAW"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MAX_DRAW</b>&nbsp;&nbsp;&nbsp;16</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a5" doxytag="PA_Sprite.h::OBJ_SIZE_8X8"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OBJ_SIZE_8X8</b>&nbsp;&nbsp;&nbsp;0,0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a6" doxytag="PA_Sprite.h::OBJ_SIZE_16X16"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OBJ_SIZE_16X16</b>&nbsp;&nbsp;&nbsp;0,1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a7" doxytag="PA_Sprite.h::OBJ_SIZE_32X32"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OBJ_SIZE_32X32</b>&nbsp;&nbsp;&nbsp;0,2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a8" doxytag="PA_Sprite.h::OBJ_SIZE_64X64"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OBJ_SIZE_64X64</b>&nbsp;&nbsp;&nbsp;0,3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a9" doxytag="PA_Sprite.h::OBJ_SIZE_16X8"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OBJ_SIZE_16X8</b>&nbsp;&nbsp;&nbsp;1,0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a10" doxytag="PA_Sprite.h::OBJ_SIZE_32X8"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OBJ_SIZE_32X8</b>&nbsp;&nbsp;&nbsp;1,1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a11" doxytag="PA_Sprite.h::OBJ_SIZE_32X16"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OBJ_SIZE_32X16</b>&nbsp;&nbsp;&nbsp;1,2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a12" doxytag="PA_Sprite.h::OBJ_SIZE_64X32"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OBJ_SIZE_64X32</b>&nbsp;&nbsp;&nbsp;1,3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a13" doxytag="PA_Sprite.h::OBJ_SIZE_8X16"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OBJ_SIZE_8X16</b>&nbsp;&nbsp;&nbsp;2,0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a14" doxytag="PA_Sprite.h::OBJ_SIZE_8X32"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OBJ_SIZE_8X32</b>&nbsp;&nbsp;&nbsp;2,1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a15" doxytag="PA_Sprite.h::OBJ_SIZE_16X32"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OBJ_SIZE_16X32</b>&nbsp;&nbsp;&nbsp;2,2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a16" doxytag="PA_Sprite.h::OBJ_SIZE_32X64"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OBJ_SIZE_32X64</b>&nbsp;&nbsp;&nbsp;2,3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a17" doxytag="PA_Sprite.h::BITS_16"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>BITS_16</b>&nbsp;&nbsp;&nbsp;65535</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a18" doxytag="PA_Sprite.h::ALL_BUT"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ALL_BUT</b>(ATR)&nbsp;&nbsp;&nbsp;(BITS_16 - ATR)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a19" doxytag="PA_Sprite.h::OBJ_X"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OBJ_X</b>&nbsp;&nbsp;&nbsp;511</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a20" doxytag="PA_Sprite.h::OBJ_Y"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OBJ_Y</b>&nbsp;&nbsp;&nbsp;255</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a21" doxytag="PA_Sprite.h::OBJ_ROT"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OBJ_ROT</b>&nbsp;&nbsp;&nbsp;256</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a22" doxytag="PA_Sprite.h::ALL_BUT_ROTSET"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ALL_BUT_ROTSET</b>&nbsp;&nbsp;&nbsp;49663</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a23" doxytag="PA_Sprite.h::ALL_BUT_PAL"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ALL_BUT_PAL</b>&nbsp;&nbsp;&nbsp;4095</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a24" doxytag="PA_Sprite.h::DBLSIZE"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>DBLSIZE</b>&nbsp;&nbsp;&nbsp;512</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a25" doxytag="PA_Sprite.h::N_COLORS"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>N_COLORS</b>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 13)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a26" doxytag="PA_Sprite.h::OBJ_MODE"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OBJ_MODE</b>&nbsp;&nbsp;&nbsp;3072</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a27" doxytag="PA_Sprite.h::OBJ_MOSAIC"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OBJ_MOSAIC</b>&nbsp;&nbsp;&nbsp;4096</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a28" doxytag="PA_Sprite.h::OBJ_HFLIP"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OBJ_HFLIP</b>&nbsp;&nbsp;&nbsp;4096</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a29" doxytag="PA_Sprite.h::OBJ_VFLIP"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OBJ_VFLIP</b>&nbsp;&nbsp;&nbsp;8192</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a30" doxytag="PA_Sprite.h::OBJ_GFX"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OBJ_GFX</b>&nbsp;&nbsp;&nbsp;1023</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a31" doxytag="PA_Sprite.h::OBJ_PRIO"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OBJ_PRIO</b>&nbsp;&nbsp;&nbsp;3072</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a32" doxytag="PA_Sprite.h::COLORS_256"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>COLORS_256</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a33" doxytag="PA_Sprite.h::COLORS_16"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>COLORS_16</b>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a34" doxytag="PA_Sprite.h::MEM_DECAL"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>MEM_DECAL</b>&nbsp;&nbsp;&nbsp;5</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a35" doxytag="PA_Sprite.h::NUMBER_DECAL"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>NUMBER_DECAL</b>&nbsp;&nbsp;&nbsp;7</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a36" doxytag="PA_Sprite.h::OAM0"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OAM0</b>&nbsp;&nbsp;&nbsp;0x07000000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a37" doxytag="PA_Sprite.h::OAM1"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OAM1</b>&nbsp;&nbsp;&nbsp;0x07000400</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga27">PA_UpdateOAM</a>()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mettre à jour les infos des sprites pour les 2 écrans. A faire dans le VBL  <a href="group___sprite.html#ga27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga28" doxytag="PA_Sprite.h::PA_UpdateOAM0"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga28">PA_UpdateOAM0</a>()&nbsp;&nbsp;&nbsp;DMA_Copy((void*)PA_obj, (void*)OAM0, 256, DMA_32NOW)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mettre à jour les infos des sprites pour l'écran 0 uniquement. A faire dans le VBL <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga29" doxytag="PA_Sprite.h::PA_UpdateOAM1"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga29">PA_UpdateOAM1</a>()&nbsp;&nbsp;&nbsp;DMA_Copy((void*)PA_obj + 256, (void*)OAM1, 256, DMA_32NOW)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mettre à jour les infos des sprites pour l'écran 1 uniquement. A faire dans le VBL <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga30">PA_UpdateSpriteGfx</a>(screen, obj_number, obj_data)&nbsp;&nbsp;&nbsp;PA_UpdateGfx(screen, PA_GetSpriteGfx(screen, obj_number), obj_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mettre à jour les Gfx d'un sprite donné  <a href="group___sprite.html#ga30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga31">PA_UpdateGfx</a>(screen, gfx_number, obj_data)&nbsp;&nbsp;&nbsp;{DMA_Copy(obj_data, (void*)(SPRITE_GFX1 + (0x200000 *  screen) + (gfx_number &lt;&lt; NUMBER_DECAL)), (used_mem[screen][gfx_number] &lt;&lt; MEM_DECAL), DMA_32NOW);}</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mettre à jour les Gfx d'un sprite donné  <a href="group___sprite.html#ga31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga32">PA_SetSpriteRotEnable</a>(screen, sprite, rotset)&nbsp;&nbsp;&nbsp;{PA_obj[screen][sprite].atr0 |= OBJ_ROT;  PA_obj[screen][sprite].atr1 = (PA_obj[screen][sprite].atr1 &amp; ALL_BUT_ROTSET) + ((rotset) &lt;&lt; 9);}</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Faire tourner et zoomer un sprite  <a href="group___sprite.html#ga32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga33">PA_SetSpriteRotDisable</a>(screen, sprite)&nbsp;&nbsp;&nbsp;{PA_obj[screen][sprite].atr0 &amp;= ALL_BUT(OBJ_ROT);  PA_obj[screen][sprite].atr1 &amp;= ALL_BUT_ROTSET;}</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Arreter de faire tourner et zoomer un sprite  <a href="group___sprite.html#ga33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga34">PA_SetSpriteX</a>(screen, obj, x)&nbsp;&nbsp;&nbsp;PA_obj[screen][obj].atr1 = (PA_obj[screen][obj].atr1 &amp; ALL_BUT(OBJ_X)) + ((x) &amp; OBJ_X)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Position X du sprite à l'écran  <a href="group___sprite.html#ga34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga35">PA_GetSpriteX</a>(screen, obj)&nbsp;&nbsp;&nbsp;(PA_obj[screen][obj].atr1 &amp; (OBJ_X))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Position X du sprite à l'écran  <a href="group___sprite.html#ga35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga36">PA_SetSpriteY</a>(screen, obj, y)&nbsp;&nbsp;&nbsp;PA_obj[screen][obj].atr0 = (PA_obj[screen][obj].atr0 &amp; ALL_BUT(OBJ_Y)) + ((y) &amp; OBJ_Y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Position Y du sprite à l'écran  <a href="group___sprite.html#ga36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga37">PA_GetSpriteY</a>(screen, obj)&nbsp;&nbsp;&nbsp;(PA_obj[screen][obj].atr0 &amp; OBJ_Y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Position Y du sprite à l'écran  <a href="group___sprite.html#ga37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga38">PA_SetSpritePal</a>(screen, obj, pal)&nbsp;&nbsp;&nbsp;PA_obj[screen][obj].atr2 = (PA_obj[screen][obj].atr2 &amp; ALL_BUT_PAL) + ((pal) &lt;&lt; 12)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changer la palette d'un sprite  <a href="group___sprite.html#ga38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga39">PA_GetSpritePal</a>(screen, obj)&nbsp;&nbsp;&nbsp;(PA_obj[screen][obj].atr2 &gt;&gt; 12)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Palette d'un sprite  <a href="group___sprite.html#ga39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga40">PA_SetSpriteDblsize</a>(screen, obj, dblsize)&nbsp;&nbsp;&nbsp;PA_obj[screen][obj].atr0 = (PA_obj[screen][obj].atr0 &amp; ALL_BUT(DBLSIZE)) + ((dblsize) &lt;&lt; 9)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Activer ou désactiver le mode Doublesize pour un sprite  <a href="group___sprite.html#ga40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga41">PA_GetSpriteDblsize</a>(screen, obj)&nbsp;&nbsp;&nbsp;((PA_obj[screen][obj].atr0 &amp; DBLSIZE) &gt;&gt; 9)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Etat du mode Doublesize pour un sprite  <a href="group___sprite.html#ga41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga42">PA_SetSpriteColors</a>(screen, sprite, n_colors)&nbsp;&nbsp;&nbsp;PA_obj[screen][sprite].atr0 = (PA_obj[screen][sprite].atr0 &amp; ALL_BUT(N_COLORS)) + ((n_colors) &lt;&lt; 13)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changer le mode de couleur du sprite  <a href="group___sprite.html#ga42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga43">PA_GetSpriteColors</a>(screen, sprite)&nbsp;&nbsp;&nbsp;((PA_obj[screen][sprite].atr0 &amp; N_COLORS) &gt;&gt; 13)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mode de couleur d'un sprite  <a href="group___sprite.html#ga43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga44">PA_SetSpriteMode</a>(screen, sprite, obj_mode)&nbsp;&nbsp;&nbsp;PA_obj[screen][sprite].atr0 = (PA_obj[screen][sprite].atr0 &amp; ALL_BUT(OBJ_MODE)) + ((obj_mode) &lt;&lt; 10)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Régler le mode d'un sprite : 0 pour normal, 1 pour transparent, 2 pour fenetre  <a href="group___sprite.html#ga44"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga45">PA_GetSpriteMode</a>(screen, obj)&nbsp;&nbsp;&nbsp;((PA_obj[screen][obj].atr0 &amp; OBJ_MODE) &gt;&gt; 10)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mode d'un sprite : 0 pour normal, 1 pour transparent, 2 pour fenetre  <a href="group___sprite.html#ga45"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga46">PA_SetSpriteMosaic</a>(screen, obj, mosaic)&nbsp;&nbsp;&nbsp;PA_obj[screen][obj].atr0 = (PA_obj[screen][obj].atr0 &amp; ALL_BUT(OBJ_MOSAIC)) + ((mosaic) &lt;&lt; 12)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mettre ou non un sprite en mode mosaic  <a href="group___sprite.html#ga46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga47">PA_GetSpriteMosaic</a>(screen, obj)&nbsp;&nbsp;&nbsp;((PA_obj[screen][obj].atr0 &amp; OBJ_MOSAIC) &gt;&gt; 12)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Si un sprite est en mode mosaic  <a href="group___sprite.html#ga47"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga48">PA_SetSpriteHflip</a>(screen, obj, hflip)&nbsp;&nbsp;&nbsp;PA_obj[screen][obj].atr1 = (PA_obj[screen][obj].atr1 &amp; ALL_BUT(OBJ_HFLIP)) + ((hflip) &lt;&lt; 12)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Utiliser ou non le flip horizontal pour un sprite  <a href="group___sprite.html#ga48"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga49">PA_GetSpriteHflip</a>(screen, obj)&nbsp;&nbsp;&nbsp;((PA_obj[screen][obj].atr1 &amp; OBJ_HFLIP) &gt;&gt; 12)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">S'il y a un flip horizontal pour un sprite  <a href="group___sprite.html#ga49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga50">PA_SetSpriteVflip</a>(screen, obj, vflip)&nbsp;&nbsp;&nbsp;PA_obj[screen][obj].atr1 = (PA_obj[screen][obj].atr1 &amp; ALL_BUT(OBJ_VFLIP)) + ((vflip) &lt;&lt; 13)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Utiliser ou non le flip vertical pour un sprite  <a href="group___sprite.html#ga50"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga51">PA_GetSpriteVflip</a>(screen, obj)&nbsp;&nbsp;&nbsp;((PA_obj[screen][obj].atr1 &amp; OBJ_VFLIP) &gt;&gt; 13)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Si le flip vertical est utilisé ou non pour un sprite  <a href="group___sprite.html#ga51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga52">PA_SetSpriteGfx</a>(screen, obj, gfx)&nbsp;&nbsp;&nbsp;PA_obj[screen][obj].atr2 = (PA_obj[screen][obj].atr2 &amp; ALL_BUT(OBJ_GFX)) + ((gfx) &amp; OBJ_GFX)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modifier les graphismes utilisés par un sprite  <a href="group___sprite.html#ga52"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga53">PA_GetSpriteGfx</a>(screen, obj)&nbsp;&nbsp;&nbsp;(PA_obj[screen][obj].atr2 &amp; OBJ_GFX)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Récupérer le gfx utilisés par un sprite  <a href="group___sprite.html#ga53"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga54">PA_SetSpritePrio</a>(screen, obj, prio)&nbsp;&nbsp;&nbsp;PA_obj[screen][obj].atr2 = (PA_obj[screen][obj].atr2 &amp; ALL_BUT(OBJ_PRIO)) + ((prio) &lt;&lt; 10)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Régler la priorité d'un sprite par rapport au Bg.  <a href="group___sprite.html#ga54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga55">PA_GetSpritePrio</a>(screen, obj)&nbsp;&nbsp;&nbsp;((PA_obj[screen][obj].atr2 &amp; OBJ_PRIO) &gt;&gt; 10)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Récupérer la priorité d'un sprite par rapport au Bg.  <a href="group___sprite.html#ga55"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga56">PA_GetSpriteLx</a>(screen, sprite)&nbsp;&nbsp;&nbsp;PA_size[PA_obj[screen][sprite].atr0 &gt;&gt; 14][PA_obj[screen][sprite].atr1 &gt;&gt; 14].lx</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Récupérer la largeur d'un sprite  <a href="group___sprite.html#ga56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga57">PA_GetSpriteLy</a>(screen, sprite)&nbsp;&nbsp;&nbsp;PA_size[PA_obj[screen][sprite].atr0 &gt;&gt; 14][PA_obj[screen][sprite].atr1 &gt;&gt; 14].ly</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Récupérer la hauteur d'un sprite  <a href="group___sprite.html#ga57"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga58">PA_CloneSprite</a>(screen, obj, target)&nbsp;&nbsp;&nbsp;{PA_obj[screen][obj].atr0 = PA_obj[screen][target].atr0; PA_obj[screen][obj].atr1 = PA_obj[screen][target].atr1; PA_obj[screen][obj].atr2 = PA_obj[screen][target].atr2; ++obj_per_gfx[screen][PA_GetSpriteGfx(screen, target)];}</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cloner un sprite. Marche uniquement pour les sprites sur un meme écran  <a href="group___sprite.html#ga58"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga59">PA_SetSpritePixel</a>(screen, sprite, x, y, color)&nbsp;&nbsp;&nbsp;PA_SetSpritePixelEx(screen, sprite, PA_GetSpriteLx(screen, sprite), PA_GetSpriteColors(screen, sprite), x, y, color)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mettre un pixel d'un sprite à une couleur donnée. Comme PA_SetSpritePixelEx, avec moins d'options, mais un peu plus lent  <a href="group___sprite.html#ga59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga60">PA_GetSpritePixel</a>(screen, sprite, x, y)&nbsp;&nbsp;&nbsp;PA_GetSpritePixelEx(screen, sprite, PA_GetSpriteLx(screen, sprite), PA_GetSpriteColors(screen, sprite), x, y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Récupérer la couleur d'un pixel d'un sprite. Comme PA_GetSpritePixelEx, avec moins d'options, mais un peu plus lent  <a href="group___sprite.html#ga60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga61">PA_SpriteDrawNot</a>(draw_number)&nbsp;&nbsp;&nbsp;PA_DrawSprite[draw_number].wasdrawing = 0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Doit etre mis si un sprite dessinable est initialisé et que l'on ne dessine pas dessus actuellement  <a href="group___sprite.html#ga61"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Fonctions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">u16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga0">PA_CreateGfx</a> (bool screen, void *obj_data, u8 obj_shape, u8 obj_size, u8 color_mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Charger en mémoire un gfx à utiliser plus tard pour un sprite. Renvoie le numéro en mémoire.  <a href="group___sprite.html#ga0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga1" doxytag="PA_Sprite.h::PA_ResetSpriteSys"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga1">PA_ResetSpriteSys</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remise à 0 du système de sprite, de la mémoire... <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga2">PA_CreateSprite</a> (bool screen, u8 obj_number, void *obj_data, u8 obj_shape, u8 obj_size, u8 color_mode, u8 palette, s16 x, s16 y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creer un sprite avec ses gfx... Ceci est la version simple de la fonction  <a href="group___sprite.html#ga2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga3">PA_CreateSpriteEx</a> (bool screen, u8 obj_number, void *obj_data, u8 obj_shape, u8 obj_size, u8 color_mode, u8 palette, u8 obj_mode, bool mosaic, bool hflip, bool vflip, u8 prio, bool dblsize, s16 x, s16 y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creer un sprite avec ses gfx... Ceci est la version complexe de la fonction  <a href="group___sprite.html#ga3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga4">PA_Create16bitSpriteEx</a> (bool screen, u8 obj_number, void *obj_data, u8 obj_shape, u8 obj_size, bool mosaic, bool hflip, bool vflip, u8 prio, bool dblsize, s16 x, s16 y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creer un sprite de 16 bits avec ses gfx... Ceci est la version complexe de la fonction. Attention : un sprite de 16 bits DOIT etre large de 128 pixels, meme si ce sprite ne prend qu'une petite partie sur la gauche  <a href="group___sprite.html#ga4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga5">PA_Create16bitSprite</a> (bool screen, u8 obj_number, void *obj_data, u8 obj_shape, u8 obj_size, s16 x, s16 y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creer un sprite de 16 bits avec ses gfx... Ceci est la version simple de la fonction. Attention : un sprite de 16 bits DOIT etre large de 128 pixels, meme si ce sprite ne prend qu'une petite partie sur la gauche  <a href="group___sprite.html#ga5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga6">PA_CreateSpriteFromGfx</a> (bool screen, u8 obj_number, u16 obj_gfx, u8 obj_shape, u8 obj_size, u8 color_mode, u8 palette, s16 x, s16 y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creer un sprite avec ses gfx... Ceci est la version simple de la fonction  <a href="group___sprite.html#ga6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga7">PA_CreateSpriteExFromGfx</a> (bool screen, u8 obj_number, u16 obj_gfx, u8 obj_shape, u8 obj_size, u8 color_mode, u8 palette, u8 obj_mode, bool mosaic, bool hflip, bool vflip, u8 prio, bool dblsize, s16 x, s16 y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creer un sprite avec ses gfx... Ceci est la version complexe de la fonction  <a href="group___sprite.html#ga7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga8">PA_DeleteGfx</a> (bool screen, u16 obj_gfx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Effacer un Gfx. Si un sprite l'utilisait, il deviendra invisible...  <a href="group___sprite.html#ga8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga9">PA_DeleteSprite</a> (bool screen, u8 obj_number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Effacer un sprite. S'il était le seul à utiliser un gfx, il sera effacé lui aussi  <a href="group___sprite.html#ga9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga10">PA_SetRotset</a> (bool screen, u8 rotset, s16 angle, u16 zoomx, u16 zoomy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Faire tourner et zoomer un sprite  <a href="group___sprite.html#ga10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga11">PA_SetRotsetNoZoom</a> (bool screen, u8 rotset, s16 angle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Faire tourner un sprite sans zoomer. C'est un peu plus rapide que la fonction PA_SetRotset  <a href="group___sprite.html#ga11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga12">PA_SetRotsetNoAngle</a> (bool screen, u8 rotset, u16 zoomx, u16 zoomy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Zoomer un sprite sans le faire tourner. C'est un peu plus rapide que la fonction PA_SetRotset  <a href="group___sprite.html#ga12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga13">PA_SetSpriteXY</a> (bool screen, u8 sprite, s16 x, s16 y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Position X et Y du sprite à l'écran  <a href="group___sprite.html#ga13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga14">PA_SetSpriteAnimEx</a> (bool screen, u8 sprite, u8 lx, u8 ly, u8 ncolors, s16 animframe)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Régler l'image du sprite dans l'animation. Cette fonction est plus rapide que PA_SetSpriteAnim parce qu'elle n'a pas à rechercher les dimensions du sprite  <a href="group___sprite.html#ga14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga15">PA_SetSpriteAnim</a> (bool screen, u8 sprite, s16 animframe)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Régler l'image du sprite dans l'animation. Identique à PA_SetSpriteAnimEx, mais plus simple à utiliser, par contre plus lent  <a href="group___sprite.html#ga15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga16">PA_StartSpriteAnim</a> (bool screen, u8 sprite, s16 firstframe, s16 lastframe, s16 speed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Démarre une animation de sprite. Une fois démarrée, elle continue tant qu'on ne l'arrête pas !  <a href="group___sprite.html#ga16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga17">PA_StopSpriteAnim</a> (bool screen, u8 sprite)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Arrêter une animation de sprite  <a href="group___sprite.html#ga17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga18">PA_SetSpriteAnimFrame</a> (bool screen, u8 sprite, u16 frame)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changer le numéro actuel de la frame d'animation  <a href="group___sprite.html#ga18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">u16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga19">PA_GetSpriteAnimFrame</a> (bool screen, u8 sprite)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Renvoie le numéro actuel de la frame d'animation  <a href="group___sprite.html#ga19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga20">PA_SetSpriteAnimSpeed</a> (bool screen, u8 sprite, s16 speed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changer la vitesse de l'animation  <a href="group___sprite.html#ga20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">u16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga21">PA_GetSpriteAnimSpeed</a> (bool screen, u8 sprite)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Renvoie la vitesse de l'animation  <a href="group___sprite.html#ga21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga22">PA_SpriteAnimPause</a> (bool screen, u8 sprite, bool pause)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mettre en Pause en remettre en lecture une animation de sprite  <a href="group___sprite.html#ga22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga23">PA_SetSpritePixelEx</a> (bool screen, u8 sprite, u8 hsize, u8 n_colors, u8 x, u8 y, u8 color)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mettre un pixel d'un sprite à une couleur donnée  <a href="group___sprite.html#ga23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga24">PA_GetSpritePixelEx</a> (bool screen, u8 sprite, u8 hsize, u8 n_colors, u8 x, u8 y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Récupérer la couleur d'un pixel d'un sprite  <a href="group___sprite.html#ga24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga25">PA_InitSpriteDraw</a> (bool screen, u8 sprite, u8 draw_number, u8 drawsize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise un sprite pour pouvoir dessiner dessus !  <a href="group___sprite.html#ga25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sprite.html#ga26">PA_SpriteDraw</a> (u8 draw_number, s16 x, s16 y, u16 color)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dessiner sur un sprite intialisé... Doit etre utilisé à tous les tours, sinon il faut faire PA_SpriteDrawNot si on ne dessine pas...  <a href="group___sprite.html#ga26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a114" doxytag="PA_Sprite.h::PA_UpdateSpriteAnims"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_UpdateSpriteAnims</b> (void)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a73" doxytag="PA_Sprite.h::PA_SIN"></a>
const s16&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_SIN</b> [512]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a74" doxytag="PA_Sprite.h::PA_size"></a>
const PA_sizes&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_size</b> [3][4]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a75" doxytag="PA_Sprite.h::n_free_mem"></a>
u16&nbsp;</td><td class="memItemRight" valign="bottom"><b>n_free_mem</b> [2]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a76" doxytag="PA_Sprite.h::used_mem"></a>
u8&nbsp;</td><td class="memItemRight" valign="bottom"><b>used_mem</b> [2][1024]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a77" doxytag="PA_Sprite.h::obj_per_gfx"></a>
u8&nbsp;</td><td class="memItemRight" valign="bottom"><b>obj_per_gfx</b> [2][1024]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a78" doxytag="PA_Sprite.h::free_mem"></a>
mem_usage&nbsp;</td><td class="memItemRight" valign="bottom"><b>free_mem</b> [2][1024]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a79" doxytag="PA_Sprite.h::FirstGfx"></a>
u16&nbsp;</td><td class="memItemRight" valign="bottom"><b>FirstGfx</b> [2]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a80" doxytag="PA_Sprite.h::PA_obj_sizes"></a>
const u16&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_obj_sizes</b> [4][3]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a81" doxytag="PA_Sprite.h::PA_obj"></a>
obj_inf&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_obj</b> [2][128]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a82" doxytag="PA_Sprite.h::PA_DrawSprite"></a>
PA_DrawSprites&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_DrawSprite</b> [MAX_DRAW]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a83" doxytag="PA_Sprite.h::PA_SpriteBuffer"></a>
unsigned char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_SpriteBuffer</b> [MAX_DRAW]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a84" doxytag="PA_Sprite.h::PA_SpriteAnimP"></a>
u16 *&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_SpriteAnimP</b> [2][1024]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a85" doxytag="PA_Sprite.h::nspriteanims"></a>
s16&nbsp;</td><td class="memItemRight" valign="bottom"><b>nspriteanims</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a86" doxytag="PA_Sprite.h::spriteanims"></a>
spriteanim *&nbsp;</td><td class="memItemRight" valign="bottom"><b>spriteanims</b> [2]</td></tr>

</table>
<hr><a name="_details"></a><h2>Description détaillée</h2>
Everything concerning the sprite system. 
<p>
This file contains all macros, variables, and prototypes regarding the sprite system (OAM, Sprite mouvement, Gfx loading...)<hr size="1"><address style="align: right;"><small>Généré le Wed Dec 14 11:50:59 2005 pour PAlib par&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
