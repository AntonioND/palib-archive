<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>PAlib: Référence du fichier PA_Tile.h</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Généré par Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="index.html">Page&nbsp;principale</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">Liste&nbsp;des&nbsp;fichiers</a> | <a class="qindex" href="globals.html">Portée&nbsp;globale</a>  | <span class="search">Rechercher&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Référence du fichier PA_Tile.h</h1>Everything concerning the Bg Tile modes. <a href="#_details">Plus de détails...</a>
<p>

<p>
<a href="_p_a___tile_8h-source.html">Aller au code source de ce fichier.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Structures de données</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>scrollpositions</b></td></tr>

<tr><td colspan="2"><br><h2>Macros</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a0" doxytag="PA_Tile.h::CharBaseBlock"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CharBaseBlock</b>(screen, n)&nbsp;&nbsp;&nbsp;(((n)*0x4000) + 0x6000000 + (0x200000 *  screen))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a1" doxytag="PA_Tile.h::ScreenBaseBlock"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ScreenBaseBlock</b>(screen, n)&nbsp;&nbsp;&nbsp;(((n)*0x800) + 0x6000000 + (0x200000 *  screen))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a2" doxytag="PA_Tile.h::BG_COLOR16"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>BG_COLOR16</b>&nbsp;&nbsp;&nbsp;0x00</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3" doxytag="PA_Tile.h::BG_COLOR256"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>BG_COLOR256</b>&nbsp;&nbsp;&nbsp;0x80</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a4" doxytag="PA_Tile.h::CHAR_SHIFT"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CHAR_SHIFT</b>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a5" doxytag="PA_Tile.h::SCREEN_SHIFT"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>SCREEN_SHIFT</b>&nbsp;&nbsp;&nbsp;8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a6" doxytag="PA_Tile.h::WRAPAROUND"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>WRAPAROUND</b>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a7" doxytag="PA_Tile.h::SCREEN_TILES"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>SCREEN_TILES</b>&nbsp;&nbsp;&nbsp;24576</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a8" doxytag="PA_Tile.h::REG_BGSCREEN0"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>REG_BGSCREEN0</b>&nbsp;&nbsp;&nbsp;0x04000000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a9" doxytag="PA_Tile.h::REG_BGSCREEN1"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>REG_BGSCREEN1</b>&nbsp;&nbsp;&nbsp;0x04001000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a10" doxytag="PA_Tile.h::REG_BGSCREEN"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>REG_BGSCREEN</b>(screen)&nbsp;&nbsp;&nbsp;(0x04000000 + (screen * 0x1000))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a11" doxytag="PA_Tile.h::REG_BGCNT"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>REG_BGCNT</b>(screen, bg_number)&nbsp;&nbsp;&nbsp;(0x4000008 + (screen * 0x1000) + (bg_number &lt;&lt; 1))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a12" doxytag="PA_Tile.h::REG_BGSCROLLX"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>REG_BGSCROLLX</b>&nbsp;&nbsp;&nbsp;0x4000010</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a13" doxytag="PA_Tile.h::REG_BGSCROLLY"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>REG_BGSCROLLY</b>&nbsp;&nbsp;&nbsp;0x4000012</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a14" doxytag="PA_Tile.h::BG_256X256"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>BG_256X256</b>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a15" doxytag="PA_Tile.h::BG_512X256"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>BG_512X256</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a16" doxytag="PA_Tile.h::BG_256X512"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>BG_256X512</b>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a17" doxytag="PA_Tile.h::BG_512X512"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>BG_512X512</b>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a18" doxytag="PA_Tile.h::BG_ROT_128X128"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>BG_ROT_128X128</b>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a19" doxytag="PA_Tile.h::BG_ROT_256X256"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>BG_ROT_256X256</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a20" doxytag="PA_Tile.h::BG_ROT_512X512"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>BG_ROT_512X512</b>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a21" doxytag="PA_Tile.h::BG_ROT_1024X1024"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>BG_ROT_1024X1024</b>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a22" doxytag="PA_Tile.h::TILE_N"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>TILE_N</b>&nbsp;&nbsp;&nbsp;1023</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a23" doxytag="PA_Tile.h::TILE_PAL"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>TILE_PAL</b>&nbsp;&nbsp;&nbsp;61440</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a24" doxytag="PA_Tile.h::TILE_HFLIP"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>TILE_HFLIP</b>&nbsp;&nbsp;&nbsp;1024</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a25" doxytag="PA_Tile.h::TILE_VFLIP"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>TILE_VFLIP</b>&nbsp;&nbsp;&nbsp;2048</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a26" doxytag="PA_Tile.h::PA_BGXX"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_BGXX</b>(screen, bg)&nbsp;&nbsp;&nbsp;_REG32(0x4000008 + (0x1000 * screen) + (bg &lt;&lt; 4))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a27" doxytag="PA_Tile.h::PA_BGXY"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_BGXY</b>(screen, bg)&nbsp;&nbsp;&nbsp;_REG32(0x400000C + (0x1000 * screen) + (bg &lt;&lt; 4))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a28" doxytag="PA_Tile.h::PA_BGXPA"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_BGXPA</b>(screen, bg)&nbsp;&nbsp;&nbsp;_REG16(0x4000000 + (0x1000 * screen) + (bg &lt;&lt; 4))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a29" doxytag="PA_Tile.h::PA_BGXPB"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_BGXPB</b>(screen, bg)&nbsp;&nbsp;&nbsp;_REG16(0x4000002 + (0x1000 * screen) + (bg &lt;&lt; 4))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a30" doxytag="PA_Tile.h::PA_BGXPC"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_BGXPC</b>(screen, bg)&nbsp;&nbsp;&nbsp;_REG16(0x4000004 + (0x1000 * screen) + (bg &lt;&lt; 4))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a31" doxytag="PA_Tile.h::PA_BGXPD"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_BGXPD</b>(screen, bg)&nbsp;&nbsp;&nbsp;_REG16(0x4000006 + (0x1000 * screen) + (bg &lt;&lt; 4))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga27">PA_HideBg</a>(screen, bg_select)&nbsp;&nbsp;&nbsp;_REG16(REG_BGSCREEN(screen)) &amp;= ~(0x100 &lt;&lt; (bg_select))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cacher un fond.  <a href="group___tile.html#ga27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga28">PA_ShowBg</a>(screen, bg_select)&nbsp;&nbsp;&nbsp;_REG16(REG_BGSCREEN(screen)) |= (0x100 &lt;&lt; (bg_select))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Afficher un fond auparavant caché.  <a href="group___tile.html#ga28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga29">PA_ResetBg</a>(screen)&nbsp;&nbsp;&nbsp;_REG16(REG_BGSCREEN(screen)) &amp;= ~(0xF00)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reinitialiser les fonds d'un écran. En fait ca ne fait que cacher tous les fonds  <a href="group___tile.html#ga29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga30">PA_LoadBgTiles</a>(screen, bg_select, bg_tiles)&nbsp;&nbsp;&nbsp;PA_LoadBgTilesEx(screen, bg_select, (void*)bg_tiles, SIZEOF_16BIT(bg_tiles))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Charger un tileset en mémoire  <a href="group___tile.html#ga30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga31">PA_LoadTiledBg</a>(screen, bg_number, bg_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">On ne pourra jamais rendre ca plus simple... Charge un fond de type TiledBg converti avec PAGfx, en mettant les tiles, la map, et meme la palette ! Seulement en mode 256 couleurs  <a href="group___tile.html#ga31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga32">PA_LoadSimpleBg</a>(screen, bg_select, bg_tiles, bg_map, bg_size, wraparound, color_mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Facon simple de cahrger un fond. Combine PA_InitBg, PA_LoadBgTiles, et PA_LoadBgMap  <a href="group___tile.html#ga32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga33">PA_LoadRotBg</a>(screen, bg_select, bg_tiles, bg_map, bg_size, wraparound)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Charger un fond pour les rotations/zoom ! Attention, il faut avant utiliser PA_SetVideoMode avec 1 pour utiliser un fond rotatif (le fond 3 uniquement !), ou 2 pour 2 fonds (2 et 3). Le fond DOIT etre de 256 couleurs  <a href="group___tile.html#ga33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga34">PA_LoadBg</a>(screen, bg_select, bg_tiles, tile_size, bg_map, bg_size, wraparound, color_mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Facon la plus simple de cahrger un fond. Combine PA_InitBg, PA_LoadBgTiles, et PA_LoadBgMap  <a href="group___tile.html#ga34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga35">PA_BGScrollX</a>(screen, bg_number, x)&nbsp;&nbsp;&nbsp;_REG16(REG_BGSCROLLX + ((screen) * 0x1000) + ((bg_number) &lt;&lt; 2)) = (x)&amp;1023</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scroll horizontal de n'importe quel fond  <a href="group___tile.html#ga35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga36">PA_BGScrollY</a>(screen, bg_number, y)&nbsp;&nbsp;&nbsp;_REG16(REG_BGSCROLLY + ((screen) * 0x1000) + ((bg_number) &lt;&lt; 2)) = (y)&amp;1023</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scroll vertical de n'importe quel fond  <a href="group___tile.html#ga36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga37">PA_BGScrollXY</a>(screen, bg_number, x, y)&nbsp;&nbsp;&nbsp;{PA_BGScrollX(screen, bg_number, x); PA_BGScrollY(screen, bg_number, y);}</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scroll horizontal et vertical de n'importe quel fond  <a href="group___tile.html#ga37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga38">PA_SetMapTileHflip</a>(screen, bg_select, x, y, hflip)&nbsp;&nbsp;&nbsp;{*(u16*)(PA_bgmap[screen][bg_select] + ((x) &lt;&lt; 1) + ((y) &lt;&lt; 6)) &amp;= ALL_BUT(TILE_HFLIP); *(u16*)(PA_bgmap[screen][bg_select] + ((x) &lt;&lt; 1) + ((y) &lt;&lt; 6)) |= ((hflip) &lt;&lt; 10);}</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flipper une tile de la carte, horizontalement  <a href="group___tile.html#ga38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga39">PA_SetMapTileVflip</a>(screen, bg_select, x, y, vflip)&nbsp;&nbsp;&nbsp;{*(u16*)(PA_bgmap[screen][bg_select] + ((x) &lt;&lt; 1) + ((y) &lt;&lt; 6)) &amp;= ALL_BUT(TILE_VFLIP); *(u16*)(PA_bgmap[screen][bg_select] + ((x) &lt;&lt; 1) + ((y) &lt;&lt; 6)) |= ((vflip) &lt;&lt; 11);}</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flipper une tile de la carte, verticalement  <a href="group___tile.html#ga39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga40">PA_SetMapTilePal</a>(screen, bg_select, x, y, palette_number)&nbsp;&nbsp;&nbsp;{*(u16*)(PA_bgmap[screen][bg_select] + ((x) &lt;&lt; 1) + ((y) &lt;&lt; 6)) &amp;= ALL_BUT(TILE_PAL); *(u16*)(PA_bgmap[screen][bg_select] + ((x) &lt;&lt; 1) + ((y) &lt;&lt; 6)) |= ((palette_number) &lt;&lt; 12);}</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changer la palette de 16 couleurs utilisée par une tile de la carte. Marche uniquement en mode 16 couleurs pour le Bg.  <a href="group___tile.html#ga40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga41">PA_LoadTiledBitmap</a>(screen, tiled_bitmap)&nbsp;&nbsp;&nbsp;PA_LoadBg(screen, 0, tiled_bitmap, SCREEN_TILES, bitmap, BG_256X256, 1, 1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Charger un bitmap converti avec gfx2gba, comme pour un fond normal, mais sans aucune optimisation. Plus la peine d'inclure la map dans ce cas. Attention, prend tout la mémoire des fonds.  <a href="group___tile.html#ga41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga42">PA_LoadPAGfxRotBg</a>(screen, bg_select, bg_name, wraparound)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Charger un fond pour les rotations/zoom ! Attention, il faut avant utiliser PA_SetVideoMode avec 1 pour utiliser un fond rotatif (le fond 3 uniquement !), ou 2 pour 2 fonds (2 et 3). Le fond DOIT etre de 256 couleurs  <a href="group___tile.html#ga42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga43">PA_LoadLargeBg</a>(screen, bg_select, bg_tiles, bg_map, color_mode, lx, ly)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Charger et initialiser un fond pour le scrolling infini (pour les fonds de plus de 512 pixels de haut ou de large)  <a href="group___tile.html#ga43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga44">PA_LoadPAGfxLargeBg</a>(screen, bg_number, bg_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Charger et initialiser un fond pour le scrolling infini (pour les fonds de plus de 512 pixels de haut ou de large), converti avec PAGfx  <a href="group___tile.html#ga44"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga45">PA_LoadLargeBgEx</a>(screen, bg_select, bg_tiles, tile_size, bg_map, color_mode, lx, ly)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Charger et initialiser un fond pour le scrolling infini (pour les fonds de plus de 512 pixels de haut ou de large), mais ici on met soi-meme la taille des tiles  <a href="group___tile.html#ga45"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Fonctions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a64" doxytag="PA_Tile.h::PA_GetPAGfxBgSize"></a>
u8&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_GetPAGfxBgSize</b> (u16 width, u16 height)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a65" doxytag="PA_Tile.h::PA_GetPAGfxRotBgSize"></a>
u8&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_GetPAGfxRotBgSize</b> (u16 width)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a66" doxytag="PA_Tile.h::PA_LoadRotBgMap"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_LoadRotBgMap</b> (u8 screen, u8 bg_select, void *bg_map, u8 bg_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga0" doxytag="PA_Tile.h::PA_ResetBgSys"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga0">PA_ResetBgSys</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reinitialise le systeme de fonds <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga1">PA_InitBg</a> (u8 screen, u8 bg_select, u8 bg_size, u8 wraparound, u8 color_mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise un fond. A faire uniquement après avoir chargé un tileset et une map.  <a href="group___tile.html#ga1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga2">PA_LoadBgTilesEx</a> (u8 screen, u8 bg_select, void *bg_tiles, u16 size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Charger un tileset en mémoire avec une taille donnée  <a href="group___tile.html#ga2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga3">PA_ReLoadBgTiles</a> (u8 screen, u8 bg_select, void *bg_tiles)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ReCharger un tileset en mémoire  <a href="group___tile.html#ga3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga4">PA_DeleteTiles</a> (u8 screen, u8 bg_select)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Effacer un tileset en mémoire. A noter que charger un tileset efface automatiquement le tileset précédent, donc on n'aura pas souvent besoin de cette fonction...  <a href="group___tile.html#ga4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga5">PA_DeleteMap</a> (u8 screen, u8 bg_select)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Effacer une map en mémoire. A noter que charger une map efface automatiquement la map précédent, donc on n'aura pas souvent besoin de cette fonction...  <a href="group___tile.html#ga5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga6">PA_DeleteBg</a> (u8 screen, u8 bg_select)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Effacer un fond complètement (tiles + map + cacher)  <a href="group___tile.html#ga6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga7">PA_LoadBgMap</a> (u8 screen, u8 bg_select, void *bg_map, u8 bg_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Charge la carte d'un fond  <a href="group___tile.html#ga7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga8" doxytag="PA_Tile.h::PA_SetBgRot"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_SetBgRot</b> (u8 screen, u8 bg_select, s32 x_scroll, s32 y_scroll, s32 x_rotcentre, s32 y_rotcentre, s16 bg_angle, s32 bg_zoom)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga9">PA_SetMapTile</a> (u8 screen, u8 bg_select, s16 x, s16 y, s16 tile_number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change la tile gfx utilisée pour une tile donnée dans la map  <a href="group___tile.html#ga9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga10">PA_SetMapTileAll</a> (u8 screen, u8 bg_select, s16 x, s16 y, u16 tile_info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change les infos tiles utilisée pour une tile donnée dans la map  <a href="group___tile.html#ga10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga11">PA_SetLargeMapTile</a> (u8 screen, u8 bg_select, s32 x, s32 y, u32 tile_info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change les infos tiles utilisée pour une tile donnée dans la map, seulement pour les grands fonds (512 de large ou haut)  <a href="group___tile.html#ga11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga12" doxytag="PA_Tile.h::PA_SetMapTileEx"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_SetMapTileEx</b> (u8 screen, u8 bg_select, s16 x, s16 y, u16 tile_number, u8 hflip, u8 vflip, u8 palette_number)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga13">PA_InfLargeScrollX</a> (u8 screen, u8 bg_select, s32 x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Déplacer un fond à scrolling 'infini' horizontalement. Doit etre initialisé avec PA_LoadLargeBg.  <a href="group___tile.html#ga13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga14">PA_InfLargeScrollY</a> (u8 screen, u8 bg_select, s32 y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Déplacer un fond à scrolling 'infini' verticalement. Doit etre initialisé avec PA_LoadLargeBg.  <a href="group___tile.html#ga14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga15">PA_InfLargeScrollXY</a> (u8 screen, u8 bg_select, s32 x, s32 y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Déplacer un fond à scrolling 'infini' horizontalement et verticalement. Doit etre initialisé avec PA_LoadLargeBg.  <a href="group___tile.html#ga15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga16">PA_LargeScrollX</a> (u8 screen, u8 bg_select, s32 x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Déplacer un grand fond à scrolling horizontalement.Doit etre initialisé avec PA_LoadLargeBg. Cette fonction ne permet pas au fond de 'boucler' sur lui-meme, mais est bien plus rapide que InfLargeScroll...  <a href="group___tile.html#ga16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga17">PA_LargeScrollY</a> (u8 screen, u8 bg_select, s32 y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Déplacer un grand fond à scrolling verticalement. Doit etre initialisé avec PA_LoadLargeBg. Cette fonction ne permet pas au fond de 'boucler' sur lui-meme, mais est bien plus rapide que InfLargeScroll...  <a href="group___tile.html#ga17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga18">PA_LargeScrollXY</a> (u8 screen, u8 bg_select, s32 x, s32 y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Déplacer un grand fond à scrolling horizontalement et verticalement. Doit etre initialisé avec PA_LoadLargeBg. Cette fonction ne permet pas au fond de 'boucler' sur lui-meme, mais est bien plus rapide que InfLargeScroll...  <a href="group___tile.html#ga18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga19">PA_InitParallaxX</a> (u8 screen, s32 bg0, s32 bg1, s32 bg2, s32 bg3)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialiser le Parallax Scrolling pour plusieurs fonds, horizontalement. Choix de la vitesse à laquelle les fonds vont défiler par rapport aux autres... Utiliser PA_ParallaxScrollX par la suite pour scroller  <a href="group___tile.html#ga19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga20">PA_InitParallaxY</a> (u8 screen, s32 bg0, s32 bg1, s32 bg2, s32 bg3)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialiser le Parallax Scrolling pour plusieurs fonds, horizontalement. Choix de la vitesse à laquelle les fonds vont défiler par rapport aux autres... Utiliser PA_ParallaxScrollX par la suite pour scroller  <a href="group___tile.html#ga20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga21">PA_ParallaxScrollX</a> (u8 screen, s32 x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Déplacer les fonds activés pour le parallax...  <a href="group___tile.html#ga21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga22">PA_ParallaxScrollY</a> (u8 screen, s32 y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Déplacer les fonds activés pour le parallax...  <a href="group___tile.html#ga22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga23">PA_ParallaxScrollXY</a> (u8 screen, s32 x, s32 y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Déplacer les fonds activés pour le parallax...  <a href="group___tile.html#ga23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga24">PA_SetBgPrio</a> (u8 screen, u8 bg, u8 prio)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changer la priorité d'un fond  <a href="group___tile.html#ga24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga25" doxytag="PA_Tile.h::PA_CreateBgFromTiles"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_CreateBgFromTiles</b> (u8 screen, u8 bg_select, u8 bg_tiles, void *bg_map, u8 bg_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tile.html#ga26">PA_ClearBg</a> (u8 screen, u8 bg_select)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Effacer un fond donné (juste la map)  <a href="group___tile.html#ga26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a94" doxytag="PA_Tile.h::PA_InitLargeBg"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_InitLargeBg</b> (u8 screen, u8 bg_select, s32 lx, s32 ly, void *bg_map)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a51" doxytag="PA_Tile.h::PA_bgmap"></a>
u32&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_bgmap</b> [2][4]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a52" doxytag="PA_Tile.h::tilesetchar"></a>
u8&nbsp;</td><td class="memItemRight" valign="bottom"><b>tilesetchar</b> [2][4]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a53" doxytag="PA_Tile.h::bg_sizes"></a>
u16&nbsp;</td><td class="memItemRight" valign="bottom"><b>bg_sizes</b> [4]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a54" doxytag="PA_Tile.h::bg_place"></a>
u8&nbsp;</td><td class="memItemRight" valign="bottom"><b>bg_place</b> [4]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a55" doxytag="PA_Tile.h::PA_DrawBg"></a>
u16 *&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_DrawBg</b> [2]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a56" doxytag="PA_Tile.h::charblocks"></a>
u8&nbsp;</td><td class="memItemRight" valign="bottom"><b>charblocks</b> [2][70]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a57" doxytag="PA_Tile.h::tilesetsize"></a>
u16&nbsp;</td><td class="memItemRight" valign="bottom"><b>tilesetsize</b> [2][4]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a58" doxytag="PA_Tile.h::mapsize"></a>
u16&nbsp;</td><td class="memItemRight" valign="bottom"><b>mapsize</b> [2][4]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a59" doxytag="PA_Tile.h::mapchar"></a>
u8&nbsp;</td><td class="memItemRight" valign="bottom"><b>mapchar</b> [2][4]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a60" doxytag="PA_Tile.h::charsetstart"></a>
u8&nbsp;</td><td class="memItemRight" valign="bottom"><b>charsetstart</b> [2]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a61" doxytag="PA_Tile.h::PA_parallaxX"></a>
s32&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_parallaxX</b> [2][4]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a62" doxytag="PA_Tile.h::PA_parallaxY"></a>
s32&nbsp;</td><td class="memItemRight" valign="bottom"><b>PA_parallaxY</b> [2][4]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a63" doxytag="PA_Tile.h::scrollpos"></a>
scrollpositions&nbsp;</td><td class="memItemRight" valign="bottom"><b>scrollpos</b> [2][4]</td></tr>

</table>
<hr><a name="_details"></a><h2>Description détaillée</h2>
Everything concerning the Bg Tile modes. 
<p>
This file contains all the macros and variables regarding Tile modes (0-2), loading tiles and Bg, etc...<hr size="1"><address style="align: right;"><small>Généré le Sat Mar 4 12:17:13 2006 pour PAlib par&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
